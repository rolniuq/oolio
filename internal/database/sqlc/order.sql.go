// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (total, discounts, status)
VALUES ($1, $2, $3)
RETURNING id, total, discounts, status, created_at, updated_at
`

type CreateOrderParams struct {
	Total     string
	Discounts sql.NullString
	Status    sql.NullString
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.Total, arg.Discounts, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Total,
		&i.Discounts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItems = `-- name: CreateOrderItems :many
INSERT INTO order_items (order_id, product_id, quantity, price_at_time)
VALUES ($1, $2, $3, $4)
RETURNING id, order_id, product_id, quantity, price_at_time, created_at
`

type CreateOrderItemsParams struct {
	OrderID     uuid.NullUUID
	ProductID   uuid.NullUUID
	Quantity    int32
	PriceAtTime string
}

func (q *Queries) CreateOrderItems(ctx context.Context, arg CreateOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.QueryContext(ctx, createOrderItems,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.PriceAtTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.PriceAtTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, total, discounts, status, created_at, updated_at
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Total,
		&i.Discounts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT oi.id, oi.order_id, oi.product_id, oi.quantity, oi.price_at_time, oi.created_at,
       p.name, p.category, p.thumbnail_url, p.mobile_url, p.tablet_url, p.desktop_url
FROM order_items oi
JOIN products p ON oi.product_id = p.id
WHERE oi.order_id = $1
`

type GetOrderItemsByOrderIDRow struct {
	ID           uuid.UUID
	OrderID      uuid.NullUUID
	ProductID    uuid.NullUUID
	Quantity     int32
	PriceAtTime  string
	CreatedAt    sql.NullTime
	Name         string
	Category     string
	ThumbnailUrl sql.NullString
	MobileUrl    sql.NullString
	TabletUrl    sql.NullString
	DesktopUrl   sql.NullString
}

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.NullUUID) ([]GetOrderItemsByOrderIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsByOrderIDRow
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.PriceAtTime,
			&i.CreatedAt,
			&i.Name,
			&i.Category,
			&i.ThumbnailUrl,
			&i.MobileUrl,
			&i.TabletUrl,
			&i.DesktopUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders 
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, total, discounts, status, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID
	Status sql.NullString
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Total,
		&i.Discounts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
